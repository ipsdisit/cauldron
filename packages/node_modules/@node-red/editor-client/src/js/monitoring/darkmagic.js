RED.monitoring = (function () {
    const data = {};
    const settings = {
        debugType: 'dynamic', // Possible values: static, dynamic
        graphicPointsDisplayed: 10,
    };

    function darkmagic() {
        RED.nodes.eachNode(initMonitoringNodeData);

        injectHTMLIntoNode();

        RED.monitoring.view.addMonitoringModal();

        subscribeNodeCreate();

        subscribeWorkspaceChange();

        subscribeMonitoring();
    }

    function subscribeNodeCreate() {
        RED.events.on('nodes:add', (node) => {
            const observer = new MutationObserver(((mutations, me) => {
                const nodeElement = document.getElementById(node.id);
                if (nodeElement) {
                    initMonitoringNodeData(node);
                    RED.monitoring.view.injectHTMLIntoNode(node.id, node.tostatus);
                    me.disconnect(); // stop observing
                }
            }));

            // start observing
            observer.observe(document, {
                childList: true,
                subtree: true,
            });
        });
    }

    function initMonitoringNodeData(node) {
        // msg: {x: timestamp, y:value, type: type, id: _msgid}
        data[node.id] = {
            input: [],
            output: [],
            settings: {
                defaultMessages: (node.inputs == 0 ? 'output' : 'input'),
                portNumber: 0,
                enableGraphic: true,
                pauseDebug: false,
            },
        };

        RED.events.on('deploy', () => {
            for(const property in data){
                if(data[property].settings.pauseDebug){
                    data[property].settings.pauseDebug = false;
                    RED.monitoring.view.toggleBreakpointButtons(property);
                }
            }
        });
    }

    function injectHTMLIntoNode() {
        RED.view.getActiveNodes().forEach((node) => {
            if (!data[node.id]) initMonitoringNodeData(node);
            RED.monitoring.view.injectHTMLIntoNode(node.id);
            redrawLastMessages(node.id, 'input');
            redrawLastMessages(node.id, 'output');
        });
    }

    function redrawLastMessages(nodeId, eventType) {
        let eventMessages = data[nodeId][eventType];
        let filter = RED.monitoring.view.getTrackedAttribute(nodeId);

        if (eventMessages.length > 0) {
            if (Array.isArray(eventMessages[0])) eventMessages = eventMessages[0];

            value = RED.monitoring.view.updateHTMLNode(nodeId, eventMessages[eventMessages.length - 1].y,
                 eventMessages[eventMessages.length - 1].x, eventType, 0);

        }
    }

    function subscribeWorkspaceChange() {
        //RED.events.on('workspace:change', (workspace) => {
        //    injectHTMLIntoNode();
        //});

        RED.events.on('editor:save', async (node) => {
            await sleep(300);
            RED.monitoring.view.updateMonitoringSize(node.id);
        });
    }

    function subscribeMonitoring() {
        RED.comms.subscribe('monitoring', (topic, event) => {
            processMessage(event);
        });

        RED.comms.subscribe('breakpoint', (topic, event) => {
            breakpointSystem(event);
        });

        RED.comms.subscribe('debug', (topic, event) => {
            enhanceDebugNode(event);
        });
    }

    function enhanceDebugNode(event) {
        const nodeId = event.id;
        let value = event.msg;
        const {format} = event;
        const timestamp = new Date();
        if (format == 'number' || format == 'Object') value = JSON.parse(value);

        const lastMessage = RED.monitoring.data[nodeId].input.slice(-1)[0];
        if (lastMessage && typeof (lastMessage.y) !== typeof (value)) clearMessages(nodeId);

        data[nodeId].input.push({
            x: timestamp, 
            y: value, 
            type: typeof (value)
        });

        RED.monitoring.view.updateHTMLNode(nodeId, value, timestamp, 'input', 0);
    }

    function processMessage(event) {
        const nodeId = event.id;
        const currentNode = RED.nodes.node(nodeId);
        if (currentNode && currentNode.type == 'debug') return;

        const dataReceived = event.value;
        const eventType = event.type;
        const timestamp = new Date();
        const filter = RED.monitoring.view.getTrackedAttribute(nodeId)

        if (Array.isArray(dataReceived)) {
            dataReceived.map((msg, index) => {
                if (!msg) return;

                if (!data[nodeId][eventType][index]) data[nodeId][eventType][index] = [];

                if (Array.isArray(msg)) {
                    msg.map((el) => {
                        const value = findAttr(el, filter);
                        if (value == null) return;
                        // if(el.receivedTimestamp) timestamp = new Date(el.receivedTimestamp);
                        data[nodeId][eventType][index].push({
                            x: timestamp,
                            y: (settings.debugType == 'dynamic')? el : value,
                            type: typeof (value),
                            id: el._msgid,
                        });
                        RED.monitoring.view.updateHTMLNode(nodeId, value, timestamp, eventType, index);
                    });
                } else {
                    const value = findAttr(msg, filter);
                    if (value == null) return;
                    // if(msg.receivedTimestamp) timestamp = new Date(msg.receivedTimestamp);
                    data[nodeId][eventType][index].push({
                        x: timestamp, 
                        y: (settings.debugType == 'dynamic')? msg : value, 
                        type: typeof (value), 
                        id: msg._msgid,
                    });
                    RED.monitoring.view.updateHTMLNode(nodeId, value, timestamp, eventType, index);
                }
            });
        } else {
            const value = findAttr(dataReceived, filter);
            if (value == null) return;
            // if(dataReceived.receivedTimestamp) timestamp = new Date(dataReceived.receivedTimestamp);
            if (eventType == 'input') {
                data[nodeId][eventType].push({
                    x: timestamp, 
                    y: (settings.debugType == 'dynamic')? dataReceived : value,
                    type: typeof (value), 
                    id: dataReceived._msgid,
                });
            } else {
                if (!data[nodeId][eventType][0]) data[nodeId][eventType][0] = [];
                data[nodeId][eventType][0].push({
                    x: timestamp,
                    y: (settings.debugType == 'dynamic')? dataReceived : value,
                    type: typeof (value),
                    id: dataReceived._msgid,
                });
            }

            RED.monitoring.view.updateHTMLNode(nodeId, value, timestamp, eventType, 0);
        }
    }

    function clearMessages(nodeId) {
        data[nodeId].input = [];
        data[nodeId].output = [];
    }

    function breakpointSystem(event) {
        switch (event.type) {
            case 'empty_queue':
                RED.monitoring.view.clearHTMLNodeMessages(event.id);
                break;
        }
    }

    function sleep(ms) {
        return new Promise(((resolve) => setTimeout(resolve, ms)));
    }

    function updateQueue(nodeId, filter){
        data[nodeId].input.map((el, index) => {
            const value = findAttr(el.y, filter);
            if (value == null) return;
            RED.monitoring.view.updateHTMLNode(nodeId, value, el.x, 'input', index);
        });

        data[nodeId].output.map((el, index) => {
            const value = findAttr(el.y, filter);
            if (value == null) return;
            RED.monitoring.view.updateHTMLNode(nodeId, value, el.x, 'output', index);
        });
    }

    function findAttr(obj, attributes, pos = 0){
        if(Array.isArray(attributes)){
            if(obj == undefined || pos >= attributes.length){
                return obj;
            } else {
                let attr = attributes[pos];
                let name = attr.split('[')[0];
                obj = obj[name];
                // if array match all the indexes
                const reg = /(\[[0-9]\])/g;
                const arr = attr.match(reg);
                if(arr != null){
                    for(let idx of arr){
                        let num = idx.replace('[', "").replace(']', '');
                        obj = obj[+num];
                    }
                }
                return findAttr(obj, attributes, pos+1);
            }
        } else {
            return obj[attributes];
        }
    }

    return {
        darkmagic,
        data,
        settings,
        clearMessages,
        updateQueue,
        injectHTMLIntoNode,
        findAttr,
    };
}());